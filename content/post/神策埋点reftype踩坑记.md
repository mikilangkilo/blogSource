---
title: 神策埋点reftype踩坑记
date: 2019-01-16 15:30:27
tags: android
---

项目需要上报埋点，但是部分埋点需要携带reftype，而reftype却需要从上个页面报到下个页面来。

从安卓上面来讲，一个页面是一个activity的形式，而reftype需要传递，有两种方式，一种是reftype以intent的bundle参数传入，第二种是在长于activity的生命周期保存这个reftype实现存储存取方式。

第一种可以完全完美的解决的问题，但是带来的是过于繁琐的步骤，每个启动的intent都需要加，这样十分复杂，在新加的页面中这样写start()函数还是可以的，但是在我们这种有多路径，而且很多老页面中无法这样使用。并且如果单加一个reftype还可以，如果需要加上refid，from等参数，带来的更改复杂度几何度上升。

第二种是借助第三方进行传递。这个是上个版本使用的，当时是通过静态变量进行传递。在当时reftype报的不是很多的情况下，尤其是只希望观察reftype是某个过程的行为的情况下使用比较合适。

不过新的产品每次的埋点方案都很神奇，是单页面多过程埋点，需要兼顾返回清除问题，同时还需要报页面停留时长。

相对于老的静态变量存储行为就不可以这么改了。当这个变量没有和页面的部分方法捆绑的时候，这个操作会造成不可逆的效果。而如果和方法捆绑的话，则又会造成大量的逻辑重构，更加麻烦。


组内进行了一次神策的讨论（吐槽一下，其实很久之前就立项想动刀这个了，只是动刀的人一直懒着不动，终于拖到让我来弄了）。大致想法如下：

1. 仍然沿用静态变量的行为
2. 在页面中保留静态变量的实例，oncreate的时候获取，onresume的时候对全局的静态变量进行覆盖
3. 更改页面reftype的地方由之前的点击变为oncreate的时候直接获取

这样可以完全完成A->B->C->B，这么一个过程中，B记录了A的reftype，回到b的时候onresume虽然全局是B，但是由于B记录了A，onresume的时候就会使得A覆盖B。同时在没有更改reftype的时候，会保证全局reftype的行为可以传递。

思路上面比较简单，用这个来实现一些数据阶段性传递比较有意义。